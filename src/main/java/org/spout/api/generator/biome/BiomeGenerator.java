/*
 * This file is part of SpoutAPI (http://www.spout.org/).
 *
 * SpoutAPI is licensed under the SpoutDev License Version 1.
 *
 * SpoutAPI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In addition, 180 days after any changes are published, you can use the
 * software, incorporating those changes, under the terms of the MIT license,
 * as described in the SpoutDev License Version 1.
 *
 * SpoutAPI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License,
 * the MIT license and the SpoutDev License Version 1 along with this program.
 * If not, see <http://www.gnu.org/licenses/> for the GNU Lesser General Public
 * License and see <http://www.spout.org/SpoutDevLicenseV1.txt> for the full license,
 * including the MIT license.
 */
package org.spout.api.generator.biome;

import java.util.ArrayList;
import java.util.Collection;

import org.spout.api.generator.Populator;
import org.spout.api.generator.WorldGenerator;
import org.spout.api.geo.cuboid.Chunk;
import org.spout.api.math.Vector3;
import org.spout.api.util.cuboid.CuboidShortBuffer;

/**
 * Abstract Biome Generator.
 *
 * Simply extend this class and add Biomes in registerBiomes()
 *
 *
 *
 *
 */
public abstract class BiomeGenerator implements WorldGenerator {
	private final BiomeMap biomes = new BiomeMap();

	private final ArrayList<Populator> populators = new ArrayList<Populator>();
	
	protected final float spawnX;
	protected final float spawnY;
	protected final float spawnZ;

	/**
	 * Constuctor with spawn locations
	 * 
	 * @param spawnX
	 * @param spawnY
	 * @param spawnZ
	 */
	public BiomeGenerator(float spawnX, float spawnY, float spawnZ) {
		populators.add(new BiomePopulator(biomes));
		registerBiomes();
		this.spawnX = spawnX;
		this.spawnY = spawnY;
		this.spawnZ = spawnZ;
	}
	
	public BiomeGenerator() {
		this(0F,0F,0F);
	}

	/**
	 * Called during biome generator's construction phase
	 */
	public abstract void registerBiomes();

	protected void setSelector(BiomeSelector selector) {
		biomes.setSelector(selector);
	}

	/**
	 * Register a new Biome Type to be generated by this generator
	 * @param biome
	 */
	public void register(BiomeType biome) {
		biomes.addBiome(biome);
	}

	@Override
	public void generate(CuboidShortBuffer blockData, int chunkX, int chunkY, int chunkZ) {
		final int x = chunkX << Chunk.CHUNK_SIZE_BITS;
		final int z = chunkZ << Chunk.CHUNK_SIZE_BITS;
		final long seed = blockData.getWorld().getSeed();

		if (chunkY << Chunk.CHUNK_SIZE_BITS > blockData.getWorld().getHeight() - 1) {
			blockData.flood((short) 0);
			return;
		}

		for (int dx = x; dx < x + Chunk.CHUNK_SIZE; ++dx) {
			for (int dz = z; dz < z + Chunk.CHUNK_SIZE; ++dz) {
				biomes.getBiome(dx, dz, seed).generateColumn(blockData, dx, chunkY, dz);
			}
		}
	}

	@Override
	public final Populator[] getPopulators() {
		return populators.toArray(new Populator[populators.size()]);
	}

	public BiomeType getBiome(int x, int y, int z, long seed) {
		return biomes.getBiome(x, y, z, seed);
	}

	public BiomeType getBiome(int x, int z, long seed) {
		return biomes.getBiome(x, z, seed);
	}

	public Collection<BiomeType> getBiomes() {
		return biomes.getBiomes();
	}

	public void setBiome(Vector3 loc, BiomeType type) {
		biomes.setBiome(loc, type);
	}
	
	public int indexOf(BiomeType biome) {
		return biomes.indexOf(biome);
	}
}
